package Algorithm.Sorting.MergeSort

/*
خوارزمية الـ Merge Sort هي إحدى الخوارزميات الفعالة لترتيب القوائم. تعتمد هذه الخوارزمية على مبدأ "اقسم و احكم" حيث تقوم بتقسيم القائمة إلى نصفين بشكل متكرر حتى تصبح كل قائمة فرعية تحتوي على عنصر واحد فقط، ثم تقوم بدمج هذه القوائم الفرعية مرتبة.

كيف تعمل خوارزمية الـ Merge Sort؟
تقسيم القائمة: تقسم القائمة إلى نصفين متساويين (تقريبًا).
الاستدعاء المتكرر: يتم تطبيق نفس الخطوة على كل نصف من القائمة بشكل متكرر حتى تصبح كل قائمة فرعية تحتوي على عنصر واحد.
الدمج: يتم دمج القوائم الفرعية المرتبة بشكل زوجي لإنشاء قوائم أكبر مرتبة.



مزايا خوارزمية الـ Merge Sort:
كفاءة: تعمل بكفاءة عالية حتى مع قوائم كبيرة.
استقرار: تحافظ على الترتيب النسبي للعناصر المتساوية.
سهولة الفهم والتنفيذ: تعتمد على مبدأ بسيط وسهل الفهم.
نقاط ضعف:
استخدام الذاكرة: تتطلب مساحة ذاكرة إضافية لإنشاء القوائم الفرعية.
لماذا تعتبر Merge Sort فعالة؟

تقسيم و احكم: تقسيم المشكلة إلى مشاكل أصغر يجعل الحل أسهل وأكثر كفاءة.
الدمج الفعال: عملية الدمج تتم بشكل منظم وبسيط.
استخدامات Merge Sort:

تستخدم على نطاق واسع في العديد من التطبيقات، بما في ذلك:
ترتيب البيانات الضخمة.
مكتبات الترتيب القياسية في العديد من لغات البرمجة.
خوارزميات أخرى تعتمد على الترتيب.
ختامًا:
خوارزمية الـ Merge Sort هي خوارزمية قوية وفعالة لترتيب القوائم، وتعتبر خيارًا ممتازًا عندما تكون كفاءة الترتيب هي الأولوية.
 */
fun mergeSort(array: IntArray) {
    if (array.size <= 1) {
        return // قاعدة التوقف: إذا كان الحجم 1 أو أقل، فإن القائمة مرتبة بالفعل
    }

    val middle = array.size / 2
    val left = array.copyOfRange(0, middle)
    val right = array.copyOfRange(middle, array.size)

    mergeSort(left)
    mergeSort(right)

    merge(left, right, array)
}
fun merge(left: IntArray, right: IntArray, array: IntArray) {
    var i = 0
    var j = 0
    var k = 0

    while (i < left.size && j < right.size) {
        if (left[i] <= right[j]) {
            array[k++] = left[i++]
        } else {
            array[k++] = right[j++]
        }
    }

    // نسخ العناصر المتبقية (إذا وجدت)
    while (i < left.size) {
        array[k++] = left[i++]
    }
    while (j < right.size) {
        array[k++] = right[j++]
    }
}
/*
شرح الكود:
الدالة mergeSort:
تقسم القائمة إلى نصفين.
تستدعي نفسها بشكل متكرر على النصفين.
تستدعي الدالة merge لدمج القائمتين المرتبتين.
الدالة merge:
تقارن عناصر القائمتين الفرعيتين وتضع الأصغر منها في القائمة الناتجة.
تستمر في المقارنة والدمج حتى يتم استنفاد عناصر إحدى القائمتين.
تنقل أي عناصر متبقية من القائمة التي لم تستنفد إلى القائمة الناتجة. */