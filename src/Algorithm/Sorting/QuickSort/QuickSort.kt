package Algorithm.Sorting.QuickSort

/*
شرح خوارزمية الـ Quick Sort (الفرز السريع) في كوتلن
خوارزمية الـ Quick Sort هي إحدى الخوارزميات الفعالة لترتيب القوائم. تعتمد هذه الخوارزمية على مبدأ "اقسم و احكم" مثل الـ Merge Sort، ولكن بطريقة مختلفة. تقوم الـ Quick Sort بتقسيم القائمة إلى قسمين بناءً على عنصر محوري (pivot)، ثم تقوم بترتيب كل قسم على حدة بشكل متكرر.

كيف تعمل خوارزمية الـ Quick Sort؟
اختيار عنصر محوري: يتم اختيار عنصر عشوائي أو عنصر في منتصف القائمة كعنصر محوري.
تقسيم القائمة: يتم تقسيم القائمة إلى ثلاثة أجزاء:
عناصر أصغر من العنصر المحوري.
العنصر المحوري نفسه.
عناصر أكبر من العنصر المحوري.
الاستدعاء المتكرر: يتم تطبيق نفس الخطوات على القسمين الأصغر والأكبر بشكل متكرر حتى تصبح كل قائمة فرعية تحتوي على عنصر واحد.



شرح خوارزمية الـ Quick Sort (الفرز السريع) في كوتلن
خوارزمية الـ Quick Sort هي إحدى الخوارزميات الفعالة لترتيب القوائم. تعتمد هذه الخوارزمية على مبدأ "اقسم و احكم" مثل الـ Merge Sort، ولكن بطريقة مختلفة. تقوم الـ Quick Sort بتقسيم القائمة إلى قسمين بناءً على عنصر محوري (pivot)، ثم تقوم بترتيب كل قسم على حدة بشكل متكرر.

كيف تعمل خوارزمية الـ Quick Sort؟
اختيار عنصر محوري: يتم اختيار عنصر عشوائي أو عنصر في منتصف القائمة كعنصر محوري.
تقسيم القائمة: يتم تقسيم القائمة إلى ثلاثة أجزاء:
عناصر أصغر من العنصر المحوري.
العنصر المحوري نفسه.
عناصر أكبر من العنصر المحوري.
الاستدعاء المتكرر: يتم تطبيق نفس الخطوات على القسمين الأصغر والأكبر بشكل متكرر حتى تصبح كل قائمة فرعية تحتوي على عنصر واحد.
مثال في كوتلن:

fun quickSort(array: IntArray, low: Int, high: Int) {
    if (low < high) {
        val pi = partition(array, low, high)
        quickSort(array, low, pi - 1)
        quickSort(array, pi + 1, high)

    }
}

fun partition(array: IntArray, low: Int, high: Int): Int {
    val pivot = array[high]
    var i = low - 1
    for (j in low until high) {
        if (array[j] <= pivot)
 {
            i++
            // تبادل العناصر
            val temp = array[i]
            array[i] = array[j]
            array[j] = temp
        }
    }
    // تبادل العنصر المحوري مع العنصر في الموضع i+1
    val temp = array[i + 1]
    array[i + 1] = array[high]
    array[high] = temp
    return i + 1
}

fun main() {
    val numbers = intArrayOf(3, 1, 4, 1, 5, 9, 2, 6, 5, 3)
    println("Unsorted array: ${numbers.contentToString()}")

    quickSort(numbers, 0, numbers.size - 1)

    println("Sorted array: ${numbers.contentToString()}")
}

شرح الكود:
الدالة quickSort:
تستقبل المصفوفة والفهرس الأول والأخير.
تستدعي الدالة partition لتقسيم المصفوفة.
تستدعي نفسها بشكل متكرر على الأقسام الناتجة.
الدالة partition:
تختار العنصر الأخير كعنصر محوري.
تقسم المصفوفة إلى قسمين بناءً على العنصر المحوري.
تعيد مؤشر موضع العنصر المحوري الجديد.
مزايا خوارزمية الـ Quick Sort:
كفاءة: تعتبر من أسرع خوارزميات الترتيب في المتوسط.
مرونة: يمكن تطبيقها على أنواع مختلفة من البيانات.
نقاط ضعف:
أسوأ حالة: في أسوأ الحالات (عندما تكون القائمة مرتبة بالفعل أو مرتبة بترتيب عكسي)، يمكن أن تعمل ببطء شديد.
عدم الاستقرار: لا تحافظ على الترتيب النسبي للعناصر المتساوية.
مقارنة بين Merge Sort و Quick Sort:
الخاصية	Merge Sort	Quick Sort
الاستقرار	مستقر	غير مستقر
أفضل حالة	O(n log n)	O(n log n)
أسوأ حالة	O(n log n)	O(n^2)
مساحة الذاكرة الإضافية	O(n)	O(log n) في المتوسط

التصدير إلى "جداول بيانات Google"
اختيار الخوارزمية المناسبة:
يعتمد اختيار الخوارزمية المناسبة على عدة عوامل، مثل حجم البيانات، نوع البيانات، ومتطلبات الاستقرار.

ختامًا:
خوارزمية الـ Quick Sort هي خوارزمية قوية وفعالة لترتيب القوائم، وتعتبر خيارًا ممتازًا في العديد من الحالات. ومع ذلك، يجب أن تكون على دراية بأسوأ الحالات لتجنب المشاكل.
*/
fun quickSort(array: IntArray, low: Int, high: Int) {
    if (low < high) {
        val pi = partition(array, low, high)
        quickSort(array, low, pi - 1)
        quickSort(array, pi + 1, high)
    }
}

fun partition(array: IntArray, low: Int, high: Int): Int {
    val pivot = array[high]
    var i = low - 1
    for (j in low until high) {
        if (array[j] <= pivot) {
            i++
            // تبادل العناصر
            val temp = array[i]
            array[i] = array[j]
            array[j] = temp
        }
    }
    // تبادل العنصر المحوري مع العنصر في الموضع i+1
    val temp = array[i + 1]
    array[i + 1] = array[high]
    array[high] = temp
    return i + 1
}

/*
شرح الكود:
الدالة quickSort:
تستقبل المصفوفة والفهرس الأول والأخير.
تستدعي الدالة partition لتقسيم المصفوفة.
تستدعي نفسها بشكل متكرر على الأقسام الناتجة.
الدالة partition:
تختار العنصر الأخير كعنصر محوري.
تقسم المصفوفة إلى قسمين بناءً على العنصر المحوري.
تعيد مؤشر موضع العنصر المحوري الجديد.
 */

